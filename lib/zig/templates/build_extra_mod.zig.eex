<% _ = opts %>
const <%= @name %> = b.createModule(
    .{
        .root_source_file = .{.cwd_relative = "<%= @path %>"},
        .imports = &[_]std.Build.Module.Import{<%= for dep <- @deps, is_atom(dep) do%>
          .{
            .name = "<%= dep %>",
            .module = <%= dep %>
          },
        <% end %>},
        <%= if @c && @c.link_libc do %>
        .link_libc = true,
        <% end %>
        <%= if @c && @c.link_libcpp do %>
        .link_libcpp = true,
        <% end %>
        <%= if @root? do %>
        // Use target_for_modules which is set differently for nif_lib vs sema modes:
        // - nif_lib: uses resolved_target (cross-compile target, e.g., ARM64)
        // - sema: uses host_target (build machine, e.g., x86_64) so it can execute
        // Note: This means sema may analyze types with host assumptions rather than
        // target-specific sizes/layouts, but this is typically acceptable.
        .target = target_for_modules,
        .optimize = optimize,
        .error_tracing = error_tracing,
        <% end %>
    });

<%= for {dep, {src_mod, dst_mod}} <- @deps do %>
<%= @name %>.addImport("<%= dst_mod %>", <%= dep %>.module("<%= src_mod %>"));
<% end %>

<%= if @c do %>
<%= Builder.render_build(@c, name: @name) %>
<% end %>
